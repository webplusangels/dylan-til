## 2025-02-05

_오늘 한 CS 스터디 내용입니다_

## 그래프

![Image](https://github.com/user-attachments/assets/b2ca3116-7eb3-4b96-b818-b885b6901220)

**정점(Vertex)**

- 그래프에서 데이터를 담고 있는 기본 단위
- $V$로 표현 → $V = A, B, C, D, E$

**간선(Edge)**

- 정점 간의 연결 관계를 나타내는 선
- $E$로 표현 → $E = (A, B) ,(B, C), (C, D)$
- 방향의 유무 존재

**표현 방법**

- 인접 행렬(Adjacency Matrix)
  - 2차원 배열을 통해 표현하며 정점이 많고 간선이 적을 경우 비효율적 (공간 복잡도 $O(V^2)$)
  ```
    A B C D
  A 0 1 0 1
  B 1 0 1 0
  C 0 1 0 1
  D 1 0 1 0
  ```
- 인접 리스트(Adjacency List)
  - 리스트를 활용해 정점별 연결된 정점을 저장하고, 메모리 절약 가능 (공간 복잡도 $O(V + E)$)
  - 최소 그래프(Sparse Graph)에 적합
  ```
  A → B, D
  B → A, C
  C → B, D
  D → A, C
  ```

### 종류

![Image](https://github.com/user-attachments/assets/fb62c9d7-f419-41e1-9856-e2fe320ca9ea)

**방향 / 무방향 그래프**

- 방향이 존재하거나 방향이 없으며 양방향으로 이동 가능한 그래프
- 웹페이지 링크 구조나 도로 네트워크 / 소셜 네트워크 친구 관계

**가중 그래프**

- 간선마다 가중치가 부여된 그래프
- 예시: 도로에 가중치를 부여해 거리를 설정할 수 있음

**연결 / 비연결 그래프**

- 모든 정점이 최소한 하나의 간선으로 연결되거나, 그렇지 않은 그래프

**순환 / 비순환 그래프**

- 정점을 따라 이동하면 다시 돌아올 수 있는 경로가 존재하거나 존재하지 않은 그래프
- 방향 비순환 그래프는 의존성 그래프, 컴파일러 최적화, 작업 스케줄링 등에 사용

### 탐색 알고리즘

![그림은 트리이지만 그래프도 적용되니까…](https://github.com/user-attachments/assets/5ee053ba-a2b3-4e51-8836-f3a648b0d6cb)

그림은 트리이지만 그래프도 적용되니까…

1. BFS (너비 우선 탐색, Breadth-First Search)
   - 큐를 이용해 가까운 정점부터 방문
   - 최단 경로 탐색에 유용
   - 시간 복잡도 $O(V + E)$
2. DFS (깊이 우선 탐색, Depth-First Search)
   - 스택이나 재귀를 이용해 가능한 깊은 곳부터 방문
   - 경로 탐색이나 미로 찾기에 활용
   - 시간 복잡도 $O(V + E)$

### 활용

✅ **소셜 네트워크 분석 (SNS)**

✅ **네트워크 라우팅 (Internet Routing)**

✅ **지도 및 길 찾기 (Google Maps)**

✅ **웹 크롤링 (Web Crawling)**

✅ **추천 시스템 (Recommendation System)**

## 트리

![Image](https://github.com/user-attachments/assets/f403dc9e-9e2d-43a7-81d1-26294feb19ff)

### 특징

- 비순환 연결 그래프: 사이클이 없는 연결 그래프로 모든 정점이 하나의 경로로 연결되어 있음
- N개의 정점과 N-1개의 간선
- 두 노드를 연결하는 경로는 하나만 존재
- 부모-자식 관계를 가지며 위에서 아래로 내려가는 구조

**노드 (Node)**

- 데이터를 표현하는 개별 단위
- 루트 노드 → 최상단에 위치한 노드로, 트리 당 하나만 존재
- 부모 노드 vs 자식 노드 → 다른 노드를 가리키는 노드를 부모 노드, 가리켜지는 노드를 자식 노드
- 리프 노드 → 가장 아래에 자식 노드가 존재하지 않는 노드

**높이와 깊이**

- 루트에서 리프 노드까지 가장 긴 경로 → **높이**
- 루트에서 특정 노드까지의 경로 길이 → **깊이 (레벨)**

### 종류

**이진 트리**

- 자식의 노드 수가 두 개 이하인 트리
- 완전 이진 트리: 마지막 레벨을 제외한 모든 노드가 꽉 차있는 트리, 왼쪽부터 채워지며 힙에서 많이 사용됨
- 포화 이진 트리: 모든 노드가 자식 노드를 0개 또는 2개 가지는 트리
- 균형 이진 트리: 왼쪽과 오른쪽의 노드의 높이의 차이가 1 이하인 트리

**이진 탐색 트리 (Binary Search Tree)**

![Image](https://github.com/user-attachments/assets/dcc0032a-5881-4fc5-baa9-65fca085ec78)

- 왼쪽 서브 트리에는 작은 값, 오른쪽 서브 트리에는 큰 값을 저장
- 중위 순회 시 오름차순 정렬된 결과를 얻음
- 시간 복잡도 평균 $O(log\,N)$이며 최악의 경우 $O(N)$
- 편향 트리의 경우를 대비해 AVL 트리와 레드 블랙 트리를 사용

**AVL 트리**

![Image](https://github.com/user-attachments/assets/1f66fcd8-fc7d-44c1-b9ff-537d7bbc680c)

- 균형 이진 트리[연산을 $O(log\,N)$으로 유지]의 한 종류로 자동으로 균형을 맞춤
- 불균형 시에는 회전 연산을 통해 균형을 맞춤 → 일반적인 이진 탐색 트리보다 약간의 오버헤드 발생

**레드-블랙 트리**

![Image](https://github.com/user-attachments/assets/94d01f86-7915-4097-b6a9-218ff54147bb)

- 균형 이진 트리의 한 종류로 각 노드가 빨강 혹은 검정색
- 루트에서 리프까지 가는 경로의 검은색 노드 개수가 동일해야 함
- 색 변경과 회전 연산을 통해 균형을 유지
- 높이가 $O(log\,N)$ 이하로 유지되므로 연산 속도도 보장
- AVL 트리보다 회전이 적어 삽입/삭제 성능이 좋음

### 활용

✅ **파일 시스템(File System)**

✅ **데이터베이스 인덱스(B+ Tree, B Tree)**

✅ **컴파일러 문법 분석(Parse Tree)**

✅ **네트워크 라우팅(Spanning Tree, Trie)**

✅ **HTML DOM(Document Object Model)**

## 힙

![Image](https://github.com/user-attachments/assets/5c2fa36b-5b46-4fff-bf62-7fa0d8a43a29)

### 특징

**완전 이진 트리(Complete Binary Tree)**

- 왼쪽부터 차례로 채워지는 이진 트리
- 높이가 균형 잡혀 있어 이진 탐색 트리보다 연산 속도가 일정

**최대 힙 VS 최소 힙**

- 부모 노드의 값이 항상 자식 노드보다 크거나 같음 (최대값: 루트 노드)
- 부모 노드의 값이 항상 자식 노드보다 작거나 같음 (최소값: 루트 노드)

**탐색 속도 $O(N)$**

- 정렬되지 않은 완전 이진 트리이므로 전체 탐색
- 삽입/삭제 연산은 $O(log\,N)$

### 최대 힙 연산 과정

![Image](https://github.com/user-attachments/assets/231ee81e-2b5a-44c5-8ee3-c363117b8ce3)

**삽입 → $O(log\,N)$**

- 새로운 노드를 힙의 마지막 위치에 삽입
- 부모 노드와 비교해 부모보다 크면 교환
- 부모 노드보다 크지 않을 때까지 반복

**삭제 → $O(log\,N)$**

- 루트 노드를 삭제하고 마지막 노드를 루트로 이동
- 루트에서 자식 노드와 비교해 교환
- 반복

### 우선순위 큐

- 각 요소가 우선순위를 가지고 높은 우선순위를 가진 요소가 가장 먼저 제거되는 것
- 최대 힙 혹은 최소 힙 활용

### 활용

✅ **우선순위 큐(Priority Queue)**

✅ **힙 정렬(Heap Sort)**

✅ **다익스트라 알고리즘(Dijkstra Algorithm)**

✅ **이벤트 드리븐 시뮬레이션(Event-driven Simulation)**

✅ **스트림에서 K번째 최소/최대값 찾기**
