## 2025-02-24

### 개요

보조기억장치와 입출력장치에 대해서

### 보조기억장치

**종류**

- 하드 디스크 드라이브 (HDD)
- 플래시 메모리 기반 저장장치
  - SSD(Solid-State Drive)

**목적**

- 전원이 꺼져도 데이터를 안전하게 보관
- CPU가 필요로 하는 정보를 조금이라도 빠른 성능으로 메모리에게 전달

→ _안전하고 빠르게!_

## RAID

**여러 개의 보조기억장치를 하나의 보조기억장치처럼 사용**

- 데이터 보호
- 성능 향상
- 데이터 가용성 증가

### RAID0

- 데이터를 여러 곳에 나누어 저장하는 구성 방식 → **스트라이핑(Striping)**
- 빠른 입출력으로 성능이 굿
- 장애 시 데이터 손실 가능성 높음

### RAID1

- 완전한 복사본을 만들어 저장하는 구성 방식 → **미러링(Mirroring)**
- 복구 간단하고 안정성이 높아 데이터 내구성 굿
- 쓰기 성능 하락, 용량을 두 배 차지함

### ~~RAID4~~

- 패리티 정보를 저장하는 디스크가 존재하는 구성 방식
  - **패리티(Parity):** 오류 검출 정보
- 1보다 적은 디스크로 안전하게 데이터 보관
- 저장 시 병목 현상 발생 가능성
  - **컨트롤러 성능과 IOPS**

### RAID5

- 패리티를 분산하여 저장하는 구성 방식
- 4의 병목 현상 보완

### RAID6

- 2개의 서로 다른 패리티를 두는 구성 방식
- 안정성이 높음
- 쓰기 속도 더 느림 👎

### RAID10

- 미러링과 스트라이핑을 함께 두는 구성 방식
- 1과 0보다 쓰기 성능과 내구성 면에서 강점
- 디스크 활용률 낮음

| **RAID 레벨** | **읽기 성능**             | **쓰기 성능**           | **장점**           | **단점**                             |
| ------------- | ------------------------- | ----------------------- | ------------------ | ------------------------------------ |
| RAID 0        | **N배 증가 (스트라이핑)** | **N배 증가**            | 성능 최상          | 장애 시 데이터 복구 불가             |
| RAID 1        | 디스크 1개 성능           | 느림 (두 개 이상 쓰기)  | 높은 가용성        | 디스크 사용 비효율적                 |
| RAID 5        | **N-1배 증가**            | 느림 (패리티 연산 부담) | 장애 1개 복구 가능 | 쓰기 속도 낮고, rebuild 시 성능 저하 |
| RAID 6        | **N-2배 증가**            | 느림                    | 장애 2개 복구 가능 | 쓰기 속도 낮음                       |
| RAID 10       | **N/2배 증가**            | **N/2배 증가**          | 성능+가용성        | 디스크 50%만 사용 가능               |

- RAID 0: 캐시 서버, 임시 데이터 저장소에서 활용 (데이터 손실 상관없는 경우)
- RAID 1: 로그 저장, 중요 시스템 환경에서 활용 (안전성이 필요할 때)
- RAID 5: 읽기 성능이 중요한 데이터 웨어하우스, 분석 시스템에 적합
- RAID 10: 데이터베이스 운영 환경(MySQL, PostgreSQL 등)에서 자주 사용됨

> SSD **쓰기 수명 (Write Endurance)** 문제
>
> - RAID 5, 6의 **패리티 쓰기 부하가 SSD 수명을 단축**할 수 있음.
> - SSD는 자체적으로 **내장된 가비지 컬렉션과 웨어 레벨링**을 수행하는데, RAID의 동작이 이를 방해할 수 있음.
> - RAID 컨트롤러의 **캐싱 정책**이 SSD의 성능을 저하시킬 수도 있음.
>
> → RAID 10 선호, TRIM 지원 여부 확인, ZFS 고려 등

## 입출력기법

### 장치 컨트롤러와 장치 드라이버

**장치 컨트롤러**

- 입출력 장치가 컴퓨터와 연결되는 하드웨어
- CPU와 입출력장치 사이의 통신을 중개하는 역할

**장치 드라이버**

- 장치 컨트롤러가 컴퓨터(CPU)와 정보를 주고 받을 수 있게 하는 프로그램
- 보통 내장되어 있지만 특수한 장치의 경우 설치 필요

### 프로그램 입출력

**프로세서가 명령어를 통해 직접 입출력을 수행하는 방식**

> 1. CPU가 I/O 요청을 보냄
> 2. CPU가 I/O 장치가 데이터를 전송할 때까지 대기 (폴링 Polling)
> 3. I/O 장치가 준비되면 CPU가 데이터를 읽거나 씀
> 4. 작업이 끝나면 CPU가 다른 작업 수행 가능

: 단순 I/O 장치 (마우스 키보드 등), 임베디드 시스템 (CPU와 장치가 매우 밀접한)

- CPU가 I/O 장치의 응답을 기다려야 하므로 CPU 낭비 발생 (Busy-Waiting)
- I/O 작업 속도가 CPU보다 느려서 CPU 효율이 매우 낮음
- 다중 I/O 처리가 어려움

### 인터럽트 기반 입출력 (다중 인터럽트)

- **우선순위 방식**: 중요도가 높은 인터럽트를 먼저 처리
- **인터럽트 마스킹**: 중요한 인터럽트 처리 시에는 다른 인터럽트 무시

> 1. CPU가 I/O 요청을 보냄
> 2. CPU는 다른 작업 수행 가능 (대기하지 않음)
> 3. I/O 장치가 준비되면 CPU에게 인터럽트를 발생시켜 알림
> 4. CPU는 인터럽트를 처리하고 I/O 데이터를 읽거나 씀
> 5. I/O 작업이 끝나면 CPU는 원래 하던 작업을 계속 수행

: 키보드 입력, 네트워크 카드, 하드 디스크

- 인터럽트 오버헤드 발생 가능성
- 우선순위 지정 필요

> **PIC (Progammerble Interrupt Controller)**
>
> - 우선순위 판별 후 CPU에게 알려줌

### DMA 입출력

- CPU를 거치지 않고 직접 메모리에 접근하는 입출력 기능

> 1. CPU가 DMA 컨트롤러(DMAC)에게 입출력 요청을 전달
> 2. DMA 컨트롤러가 I/O 장치와 메모리 간 데이터 전송 수행
> 3. 데이터 전송이 끝나면 DMA 컨트롤러가 CPU에게 인터럽트로 완료 알림
> 4. CPU는 다른 작업을 하면서도 I/O가 빠르게 진행됨

: SSD, HDD, GPU, 비디오 스트리밍 등

- DMA 컨트롤러라는 하드웨어 필요
- CPU와 충돌 가능성 - 시스템 버스

> **입출력 버스란?**
>
> DMA 컨트롤러와 장치 컨트롤러 간을 연결하는 버스

**PICe**

- 거의 모든 하드웨어의 입출력 버스에 사용
- 레인(Lane)
  - 레인 단위로 데이터를 전송 (x1, x4, x8, x16)
  - 레인 수가 많을수록 대역폭과 성능이 향상
- 버전
  - 세대 별 최대 속도가 다름

**PCIe 4.0 x 4 ⇒ PCIe 4.0의 최대 속도 1.969MB/s \* 4만큼의 속도**

### 회고

오랜만에 복습을 하니 새로운 사실을 안 것처럼 재미있었다!
